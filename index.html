<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>Calligraphie AR - Three.js</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: transparent; }
        #ar-button {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 12px 24px; background: #222; color: white; border: none; border-radius: 4px;
            cursor: pointer; z-index: 100; font-family: sans-serif;
        }
    </style>
</head>
<body>
    <button id="ar-button">Lancer la Calligraphie AR</button>

    <script type="module">
        let container, camera, scene, renderer, controller;
        let pinceau, pavillon, table, papier;
        let isDrawing = false;
        let lineGeometries = [];

        init();
        animate();

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // Lumières
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            scene.add(light);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(1, 2, 1);
            scene.add(dirLight);

            // Rendu avec support WebXR et Alpha pour le Passthrough
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // Chargement des modèles GLTF
            const loader = new THREE.GLTFLoader();

            // 1. Pavillon
            loader.load('pavillon.glb', (gltf) => {
                pavillon = gltf.scene;
                pavillon.position.set(0, 1.636, -0.536);
                pavillon.scale.set(3.191, 3.12, 3.338);
                scene.add(pavillon);
            });

            // 2. Table et Papier
            const tableGeo = new THREE.BoxGeometry(1, 0.05, 0.6);
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x3d2b1f });
            table = new THREE.Mesh(tableGeo, tableMat);
            table.position.set(0, 0.734, -0.434);
            scene.add(table);

            const papierGeo = new THREE.PlaneGeometry(0.4, 0.5);
            const papierMat = new THREE.MeshStandardMaterial({ color: 0xfffaf0, side: THREE.DoubleSide });
            papier = new THREE.Mesh(papierGeo, papierMat);
            papier.rotation.x = -Math.PI / 2;
            papier.position.set(0, 0.03, 0);
            table.add(papier);

            // 3. Pinceau (Attaché au contrôleur)
            loader.load('pinceau.glb', (gltf) => {
                pinceau = gltf.scene;
                pinceau.scale.set(0.3, 0.3, 0.3);
                pinceau.visible = false; // Caché tant qu'on n'est pas en VR
            });

            // Bouton AR
            const button = document.getElementById('ar-button');
            button.addEventListener('click', () => {
                const sessionInit = { optionalFeatures: ['local-floor', 'bounded-floor', 'layers'] };
                // On demande spécifiquement 'immersive-ar'
                navigator.xr.requestSession('immersive-ar', sessionInit).then((session) => {
                    renderer.xr.setSession(session);
                    button.style.display = 'none';
                });
            });

            // Gestion du contrôleur droit
            controller = renderer.xr.getController(0);
            controller.addEventListener('connected', (event) => {
                if (pinceau) {
                    controller.add(pinceau);
                    pinceau.visible = true;
                    // Correction de l'offset et rotation ici
                    pinceau.position.set(0, 0, -0.15);
                    pinceau.rotation.set(Math.PI, 0, 0); 
                }
            });
            scene.add(controller);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            if (pinceau && papier) {
                checkDrawing();
            }
            renderer.render(scene, camera);
        }

        function checkDrawing() {
            const tipWorldPos = new THREE.Vector3();
            // On récupère le point au bout du pinceau (ajuster le Z selon ton modèle)
            pinceau.getWorldPosition(tipWorldPos);
            
            // Calcul du décalage (Forward offset)
            const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(pinceau.quaternion);
            tipWorldPos.add(forward.multiplyScalar(0.08)); 

            const papierWorldPos = new THREE.Vector3();
            papier.getWorldPosition(papierWorldPos);

            const distY = Math.abs(tipWorldPos.y - papierWorldPos.y);
            const distXZ = new THREE.Vector2(tipWorldPos.x - papierWorldPos.x, tipWorldPos.z - papierWorldPos.z).length();

            // Seuil de 11cm comme validé
            if (distY < 0.11 && distXZ < 0.25) {
                createInkDrop(tipWorldPos.x, papierWorldPos.y + 0.001, tipWorldPos.z);
            }
        }

        function createInkDrop(x, y, z) {
            const dotGeo = new THREE.CircleGeometry(0.008, 8);
            const dotMat = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
            const dot = new THREE.Mesh(dotGeo, dotMat);
            dot.rotation.x = -Math.PI / 2;
            dot.position.set(x, y, z);
            scene.add(dot);
        }
    </script>
</body>
</html>
